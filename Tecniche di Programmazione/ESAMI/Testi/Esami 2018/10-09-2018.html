<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=windows-1252" http-equiv="content-type">
    <title>Esame di Tecniche di Programmazione del 10/09/2018</title>
    <style>
      img {
      margin: 15px;
      }
      
      .maxwidth {
      font-family: Verdana, Geneva, sans-serif;
      max-width: 1000px;
      margin: auto;
      position: absolute;
      left: 50%;
      margin-right: -50%;
      transform: translate(-50%);
      }
      
      hr {
      border: 1px solid;
      color: gray;
      }
      
      code {
      #border: 1px solid;
      color: blue;
      }
      
      listing {
      #border: 1px solid;
      color: blue;
      }
    </style>
  </head>

  <body>
    <div class="maxwidth">
      
      <h1>Esame di Tecniche di Programmazione del 10/09/2018</h1>
     
      
      
<!----------------------------------------------------------------------------------------------------------------------------------------------->
      <hr>
      <h2>Esercizio 1</h2>
      Sia data la seguente struttura <code>Mat:</code>
      <listing>
  struct Mat {
    int cols; // numero di colonne
    int rows; // numero di righe
    int** row_ptrs; // puntatori alle righe
  };
      </listing>
      Implementare la seguente funzione C:
      <listing>
  int massimo(Mat* src);
      </listing>
      che, data in input una matrice <code>src</code>, restituisce il valore massimo 
		  della colonna la cui somma degli elementi, tra tutte le colonne della matrice, &egrave; massima.
      <h3>Esempio</h3>
      Data una struttura <code>Mat *src</code> contenente la seguente matrice <code>3x4</code>:
      <pre>
  1 1 1 0
  0 2 1 4
  0 3 0 0
      </pre>
      richiamando la seguente linea di codice:
      <listing>
  massimo(src);
      </listing>
      si ottiene 3, essendo il massimo  valore della seconda colonna, la cui somma degli elementi (1+2+3) &egrave; massima
	    rispetto a quella delle altre colonne della matrice.</p>
      
      
      
<!----------------------------------------------------------------------------------------------------------------------------------------------->
      <hr>
      <h2>Esercizio 2</h2>
      Sia data una lista i cui elementi appartengono alla seguente struttura <code>ListNode</code>:
      <listing>
  struct ListNode {
    Data info;
    ListNode *next;
  };
      </listing>
      dove ogni elemento contiene un valore intero:
      <listing>
  typedef int Data;
      </listing>
      Implementare la seguente funzione C:
      <listing>
  ListNode *subset(ListNode *list);
      </listing>
      che data in input una lista concatenata <code>list</code>,
      restituisca il puntatore ad una nuova lista concatenata che contiene i soli elementi di <code>list</code>
      i cui valori sono minori dell'elemento ad essi precedente.
	    Il primo valore di <code>list</code> deve essere sempre incluso.
      L'ordine degli elementi della lista ritornata dovr&agrave; essere quello della lista di input.
      <br><br>
      Si gestisca il caso in cui il puntatore <code>list</code> &egrave; nullo,
      restituendo un puntatore nullo.
      La lista in ingresso alla funzione non deve essere modificata in alcun modo.
      <h3>Esempio</h3>
      Data la seguente lista <code>list</code> in ingresso:
      <pre>
  5 -> 3 -> 8 -> 8 -> 7 -> 0 -> 11 -> NULL
      </pre>
      L'esecuzione della seguente linea di codice:
      <listing>
  ListNode* dest_list = subset(list);
      </listing>
      memorizza in <code>dest_list</code> il puntatore a:
      <pre>
  5 -> 3 -> 7 -> 0 -> NULL
      </pre>
      
      
      
<!----------------------------------------------------------------------------------------------------------------------------------------------->
      <hr>
      <h2>Esercizio 3</h2>
      Sia data una lista i cui elementi appartengono alla seguente struttura <code>ListNode</code>:
      <listing>
  struct ListNode {
    int info;
    struct ListNode* next;
  };
      </listing>
      Si realizzi la funzione <strong>ricorsiva </strong> C:
      <listing>
  ListNode* erase(ListNode* list, int index);
      </listing>
      che, data in input una lista <code>list</code>, restituisca una nuova lista <code>dest_list</code>
      in cui manchi solo l'elemento di <code>list</code> contenuto nella posizione <code>index</code>.
      Se l'elemento in posizione <code>index</code> non esiste, la lista in output dovr&agrave; essere uguale a quella in input.
      <h3>Esempio</h3>
      Data la seguente lista <code>list</code> in ingresso:
      <pre>
  4 -> 1 -> 3 -> 5 -> NULL
      </pre>
      L'esecuzione della seguente linea di codice:
      <listing>
  ListNode* dest_list = erase(list, 0);
      </listing>
      memorizza in <code>dest_list</code> il puntatore ad una nuova lista che contiene:
      <pre>
  1 -> 3 -> 5 -> NULL
      </pre>
    </div>
  </body>
</html>

